# Infrastructure & Operations Portfolio

## ğŸ‘¤ Profile
ã‚¤ãƒ³ãƒ•ãƒ©ï¼ITé‹ç”¨æ”¹å–„ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã€‚  
SIerã¨ã—ã¦ As-Is æ¥­å‹™ç§»ç®¡ã®ãƒªãƒ¼ãƒ‰ã€è¦ä»¶å®šç¾©ã€è©³ç´°è¨­è¨ˆã€ãƒ™ãƒ³ãƒ€ãƒ¼èª¿æ•´ã€é‹ç”¨å®šç€ã¾ã§ä¸€é€£ã®å·¥ç¨‹ã‚’æ‹…å½“ã€‚  
è¿‘å¹´ã¯ã€ŒåŠ¹ç‡åŒ–ã€ã€Œãƒ­ãƒ¼ã‚«ãƒ«ä½œæ¥­ã®æ’é™¤ã€ã‚’è»¸ã«ã€æ¥­å‹™ãƒ•ãƒ­ãƒ¼æ¨™æº–åŒ–ãƒ»è‡ªå‹•åŒ–ãƒ»ç”ŸæˆAIæ´»ç”¨ã«æ³¨åŠ›ã€‚

---

## ğŸ›  Core Strengths
- ã‚¤ãƒ³ãƒ•ãƒ©æ§‹ç¯‰ï¼é‹ç”¨ï¼ˆã‚ªãƒ³ãƒ—ãƒ¬ãƒ»ã‚¯ãƒ©ã‚¦ãƒ‰ä¸¡æ–¹ï¼‰
- æ¥­å‹™ãƒ•ãƒ­ãƒ¼æ”¹å–„ï¼ˆæ¨™æº–åŒ–ã€çœåŠ›åŒ–ã€è¦‹ãˆã‚‹åŒ–ï¼‰
- ç§»è¡Œè¨­è¨ˆãƒ»ç§»è¡Œæ–¹å¼æ¤œè¨ï¼ˆOS/MW ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚¢ãƒƒãƒ—å«ã‚€ï¼‰
- ãƒ™ãƒ³ãƒ€ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼ã‚¹ãƒ†ãƒ¼ã‚¯ãƒ›ãƒ«ãƒ€ãƒ¼èª¿æ•´
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™ï¼ˆæ‰‹é †æ›¸ã€é‹ç”¨è¨­è¨ˆã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆï¼‰
- AIæ´»ç”¨ï¼ˆãƒŠãƒ¬ãƒƒã‚¸æ¤œç´¢ãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆè‡ªå‹•ç”Ÿæˆï¼‰

---

## ğŸ’¼ Experience Summary
### â–  æ¥­å‹™ç§»ç®¡ãƒ»é‹ç”¨æ”¹å–„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ  
- ä»–ç¤¾ã‹ã‚‰ã® As-Is æ¥­å‹™ç§»ç®¡ã®ãƒªãƒ¼ãƒ‰  
- ã‚®ãƒ£ãƒƒãƒ—åˆ†æã€äº¤é€šæ•´ç†ã€è¦ä»¶ãƒ’ã‚¢ãƒªãƒ³ã‚°  
- é‹ç”¨ãƒ•ãƒ­ãƒ¼å†æ§‹ç¯‰ã€ãƒ­ãƒ¼ã‚«ãƒ«ä½œæ¥­æ’é™¤ã€æ¨™æº–åŒ–æ¨é€²  
- å®šç€åŒ–ã¾ã§ã®é‹ç”¨ã‚¬ã‚¤ãƒ‰ä½œæˆãŠã‚ˆã³æ•™è‚²

### â–  ã‚¤ãƒ³ãƒ•ãƒ©æ§‹ç¯‰ãƒ»é‹ç”¨  
- ã‚µãƒ¼ãƒæ§‹ç¯‰ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­è¨ˆ  
- æ—¢å­˜æ©Ÿå™¨ã®ãƒªãƒ—ãƒ¬ãƒ¼ã‚¹ãŠã‚ˆã³è¨­å®šå¤‰æ›´  
- ç›£è¦–è¨­è¨ˆ / ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ  
- OSãƒ»MW ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚¢ãƒƒãƒ—ï¼ç§»è¡Œè¨­è¨ˆ

### â–  ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ¼ãƒ‰  
- é€²æ—ç®¡ç† / ãƒªã‚¹ã‚¯ç®¡ç† / å“è³ªç®¡ç†  
- èª¿æ•´æ¥­å‹™ï¼ˆãƒ¦ãƒ¼ã‚¶éƒ¨é–€ã€ãƒ™ãƒ³ãƒ€ãƒ¼ã€ç¤¾å†…é–¢ä¿‚è€…ï¼‰  
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨ˆç”»ç­–å®šãƒ»æ¨é€²  
- ãƒãƒ¼ãƒ ãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆï¼ˆæ–°äººæ•™è‚²ãƒ»è¦å“¡ç®¡ç†ï¼‰

---

# AWS Internal FAQ Chatbotï¼ˆLambda + API Gatewayï¼‰

AWS Lambdaï¼ˆPythonï¼‰ã¨ API Gateway ã‚’ä½¿ã£ãŸã€
ç¤¾å†…å•ã„åˆã‚ã›ãƒ»ãƒ˜ãƒ«ãƒ—ãƒ‡ã‚¹ã‚¯å‘ã‘ã®ç°¡æ˜“ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆã®ã‚µãƒ³ãƒ—ãƒ«ã§ã™ã€‚

ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ / VPN / PCä¸å…·åˆãªã©ã®ã‚ˆãã‚ã‚‹è³ªå•ã«å¯¾ã—ã¦ã€
ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒã§è‡ªå‹•å¿œç­”ã‚’è¿”ã—ã¾ã™ã€‚

## æ§‹æˆæŠ€è¡“

- AWS Lambdaï¼ˆPythonï¼‰
- Amazon API Gateway
- Amazon CloudWatch Logs

## æƒ³å®šãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

- ç¤¾å†…ãƒãƒ¼ã‚¿ãƒ«ã‚„ Teams Bot ã‹ã‚‰ã®å•ã„åˆã‚ã›ã®ä¸€æ¬¡å›ç­”
- ãƒ˜ãƒ«ãƒ—ãƒ‡ã‚¹ã‚¯ã®è² è·è»½æ¸›
- ã‚ˆãã‚ã‚‹ FAQ ã®è‡ªå‹•åŒ–

## ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¾‹

```json
{
  "userId": "taro",
  "message": "VPNãŒæ¥ç¶šã§ãã¾ã›ã‚“"
}
{
  "userId": "taro",
  "reply": "VPNæ¥ç¶šãŒã§ããªã„å ´åˆã¯ã€ã¾ãšãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç’°å¢ƒã‚’ç¢ºèªã—ã€ç¤¾å†…ãƒ˜ãƒ«ãƒ—ãƒšãƒ¼ã‚¸ã®VPNãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°æ‰‹é †ã«æ²¿ã£ã¦ã”ç¢ºèªãã ã•ã„ã€‚",
  "timestamp": "2025-05-01T10:24:33"
}

### `lambda_function.py`

```python
import json
from datetime import datetime, timezone, timedelta

FAQ_DATA = [
    {
        "keywords": ["ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰", "ãƒ­ã‚°ã‚¤ãƒ³", "PW"],
        "answer": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãŠå¿˜ã‚Œã®å ´åˆã¯ã€ç¤¾å†…ãƒãƒ¼ã‚¿ãƒ«ã®ã€Œãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã€ã‹ã‚‰å†ç™ºè¡Œã—ã¦ãã ã•ã„ã€‚"
    },
    {
        "keywords": ["VPN", "æ¥ç¶šã§ããªã„", "ãƒªãƒ¢ãƒ¼ãƒˆ"],
        "answer": "VPNæ¥ç¶šãŒã§ããªã„å ´åˆã¯ã€ã¾ãšãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç’°å¢ƒã‚’ç¢ºèªã—ã€ç¤¾å†…ãƒ˜ãƒ«ãƒ—ãƒšãƒ¼ã‚¸ã®VPNãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°æ‰‹é †ã«æ²¿ã£ã¦ã”ç¢ºèªãã ã•ã„ã€‚"
    },
    {
        "keywords": ["ã‚ªãƒ•ã‚£ã‚¹", "å‡ºç¤¾", "å‹¤å‹™æ™‚é–“"],
        "answer": "ã‚ªãƒ•ã‚£ã‚¹ã®åˆ©ç”¨æ™‚é–“ã‚„å‡ºç¤¾ãƒ«ãƒ¼ãƒ«ã¯ã€ç¤¾å†…è¦ç¨‹ã®ã€Œå‹¤å‹™ãƒ»å‡ºç¤¾ãƒ«ãƒ¼ãƒ«ã€ã‚’ã”ç¢ºèªãã ã•ã„ã€‚"
    },
    {
        "keywords": ["PC", "ãƒ‘ã‚½ã‚³ãƒ³", "æ•…éšœ"],
        "answer": "PC ã®ä¸å…·åˆã¯é›»æºãƒ»ã‚±ãƒ¼ãƒ–ãƒ«æ¥ç¶šã‚’ç¢ºèªå¾Œã€ãƒ˜ãƒ«ãƒ—ãƒ‡ã‚¹ã‚¯ã®å•ã„åˆã‚ã›ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰ãƒã‚±ãƒƒãƒˆã‚’èµ·ç¥¨ã—ã¦ãã ã•ã„ã€‚"
    }
]

DEFAULT_ANSWER = (
    "ã™ã¿ã¾ã›ã‚“ã€å›ç­”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n"
    "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å¤‰ãˆã¦ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ã„ãŸã ãã‹ã€ãƒ˜ãƒ«ãƒ—ãƒ‡ã‚¹ã‚¯ã¾ã§ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚"
)

JST = timezone(timedelta(hours=9))


def find_answer(message: str) -> str:
    text = message.lower()
    best_score = 0
    best_answer = None

    for faq in FAQ_DATA:
        score = sum(1 for kw in faq["keywords"] if kw.lower() in text)
        if score > best_score:
            best_score = score
            best_answer = faq["answer"]

    return best_answer or DEFAULT_ANSWER


def lambda_handler(event, context):
    try:
        body = json.loads(event.get("body", "{}"))
        message = body.get("message", "")
        user = body.get("userId", "unknown")

        answer = find_answer(message)
        now = datetime.now(JST).isoformat(timespec="seconds")

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "application/json"},
            "body": json.dumps(
                {"userId": user, "reply": answer, "timestamp": now},
                ensure_ascii=False
            )
        }

    except Exception as e:
        print("Error:", e)
        return {
            "statusCode": 500,
            "body": json.dumps({"error": "internal server error"})
        }

# Azure Internal FAQ Chatbotï¼ˆAzure Functions / Pythonï¼‰

Azure Functionsï¼ˆHTTP Triggerï¼‰ã§å®Ÿè£…ã—ãŸã€
ç¤¾å†…å‘ã‘ FAQ ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆ API ã®ã‚µãƒ³ãƒ—ãƒ«ã§ã™ã€‚

AWS ç‰ˆã¨åŒã˜ FAQ ãƒ­ã‚¸ãƒƒã‚¯ã§ã€Teams ã‚„ç¤¾å†… Web ã‹ã‚‰åˆ©ç”¨ã§ãã¾ã™ã€‚

## æ§‹æˆæŠ€è¡“

- Azure Functionsï¼ˆPythonï¼‰
- HTTP Trigger
- Azure Monitorï¼ˆãƒ­ã‚°ï¼‰

## ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¾‹

```json
{"userId": "taro", "message": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å¿˜ã‚Œã¾ã—ãŸ"}
}

{
  "userId": "taro",
  "reply": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãŠå¿˜ã‚Œã®å ´åˆã¯ã€ç¤¾å†…ãƒãƒ¼ã‚¿ãƒ«ã®ã€Œãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã€ã‹ã‚‰å†ç™ºè¡Œã—ã¦ãã ã•ã„ã€‚",
  "timestamp": "2025-05-01T09:12:33"
}


### `__init__.py`

```python
import logging
import json
from datetime import datetime, timezone, timedelta
import azure.functions as func

FAQ_DATA = [
    {
        "keywords": ["ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰", "ãƒ­ã‚°ã‚¤ãƒ³"],
        "answer": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãŠå¿˜ã‚Œã®å ´åˆã¯ã€ç¤¾å†…ãƒãƒ¼ã‚¿ãƒ«ã®ã€Œãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã€ã‹ã‚‰å†ç™ºè¡Œã—ã¦ãã ã•ã„ã€‚"
    },
    {
        "keywords": ["VPN", "æ¥ç¶šã§ããªã„"],
        "answer": "VPNæ¥ç¶šãŒã§ããªã„å ´åˆã¯ã€ã¾ãšãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç’°å¢ƒã‚’ã”ç¢ºèªãã ã•ã„ã€‚"
    },
    {
        "keywords": ["ã‚ªãƒ•ã‚£ã‚¹", "å‡ºç¤¾"],
        "answer": "å‡ºç¤¾ãƒ«ãƒ¼ãƒ«ã¯ã€ç¤¾å†…è¦ç¨‹ã®ã€Œå‹¤å‹™ãƒ»å‡ºç¤¾ãƒ«ãƒ¼ãƒ«ã€ã‚’ã”ç¢ºèªãã ã•ã„ã€‚"
    },
    {
        "keywords": ["PC", "æ•…éšœ"],
        "answer": "PCä¸å…·åˆã¯ãƒ˜ãƒ«ãƒ—ãƒ‡ã‚¹ã‚¯ã‹ã‚‰ãƒã‚±ãƒƒãƒˆã‚’èµ·ç¥¨ã—ã¦ãã ã•ã„ã€‚"
    }
]

DEFAULT_ANSWER = "å›ç­”ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ˜ãƒ«ãƒ—ãƒ‡ã‚¹ã‚¯ã¸ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚"

JST = timezone(timedelta(hours=9))


def find_answer(message: str) -> str:
    text = message.lower()
    best_score = 0
    best_answer = None

    for faq in FAQ_DATA:
        score = sum(1 for kw in faq["keywords"] if kw.lower() in text)
        if score > best_score:
            best_score = score
            best_answer = faq["answer"]

    return best_answer or DEFAULT_ANSWER


def main(req: func.HttpRequest) -> func.HttpResponse:
    logging.info("Chatbot request received.")

    try:
        body = req.get_json()
        user = body.get("userId", "unknown")
        message = body.get("message", "")

        answer = find_answer(message)
        now = datetime.now(JST).isoformat(timespec="seconds")

        return func.HttpResponse(
            json.dumps(
                {"userId": user, "reply": answer, "timestamp": now},
                ensure_ascii=False
            ),
            mimetype="application/json",
            status_code=200
        )

    except Exception as e:
        logging.error(e)
        return func.HttpResponse(
            json.dumps({"error": "internal server error"}, ensure_ascii=False),
            status_code=500
        )
# AWS Asset Management Automationï¼ˆè³‡ç”£ç®¡ç†å°å¸³ãƒ•ãƒ­ãƒ¼ï¼‰

PCãƒ»å‘¨è¾ºæ©Ÿå™¨ã®ã€Œè²¸å‡ºãƒ»è¿”å´ãƒ»å»ƒæ£„ã€ãªã©ã®æ›´æ–°ã‚’ã€
DynamoDB ã«è‡ªå‹•åæ˜ ã—ã€åŒæ™‚ã« S3 ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¿å­˜ã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã§ã™ã€‚

## æ§‹æˆæŠ€è¡“

- Amazon API Gateway
- AWS Lambdaï¼ˆPythonï¼‰
- Amazon DynamoDB
- Amazon S3ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰

## ä¸»ãªé …ç›®

- assetIdï¼ˆä¾‹ï¼šPC-001ï¼‰
- assetTypeï¼ˆLaptop / Monitor ãªã©ï¼‰
- serialNumber
- statusï¼ˆin-use / returned / disposedï¼‰
- holderï¼ˆåˆ©ç”¨è€…ï¼‰
- locationï¼ˆè¨­ç½®å ´æ‰€ï¼‰
- historyï¼ˆæ›´æ–°å±¥æ­´ï¼‰

import json
from datetime import datetime, timezone, timedelta
import boto3

dynamodb = boto3.resource("dynamodb")
s3 = boto3.client("s3")

TABLE_NAME = "AssetManagementTable"
BACKUP_BUCKET = "asset-management-backups"
JST = timezone(timedelta(hours=9))


def build_response(body, status_code=200):
    return {
        "statusCode": status_code,
        "headers": {"Content-Type": "application/json"},
        "body": json.dumps(body, ensure_ascii=False)
    }


def update_asset(record):
    now = datetime.now(JST).isoformat(timespec="seconds")
    table = dynamodb.Table(TABLE_NAME)

    existing = table.get_item(Key={"assetId": record["assetId"]}).get("Item")
    new_history = {
        "timestamp": now,
        "status": record.get("status"),
        "holder": record.get("holder"),
        "location": record.get("location"),
        "note": record.get("note"),
        "updateUser": record.get("updateUser")
    }

    history = existing.get("history", []) if existing else []
    history.append(new_history)

    updated_item = {
        "assetId": record["assetId"],
        "assetType": record.get("assetType"),
        "serialNumber": record.get("serialNumber"),
        "model": record.get("model"),
        "status": record.get("status"),
        "holder": record.get("holder"),
        "location": record.get("location"),
        "note": record.get("note"),
        "updatedAt": now,
        "history": history
    }

    table.put_item(Item=updated_item)
    return updated_item


def backup_to_s3(asset):
    key = f"backups/{asset['assetId']}.json"
    body = json.dumps(asset, ensure_ascii=False, indent=2)
    s3.put_object(
        Bucket=BACKUP_BUCKET,
        Key=key,
        Body=body.encode("utf-8"),
        ContentType="application/json"
    )
    return key


def lambda_handler(event, context):
    try:
        body = json.loads(event.get("body", "{}"))

        updated = update_asset(body)
        key = backup_to_s3(updated)

        return build_response({
            "assetId": updated["assetId"],
            "status": updated["status"],
            "backupS3Key": key,
            "message": "asset updated & backup stored"
        })

    except Exception as e:
        print("Error:", e)
        return build_response({"error": "internal server error"}, 500)

# PC Repair Invoice Automationï¼ˆPCä¿®ç†è«‹æ±‚æ›¸ãƒ•ãƒ­ãƒ¼ï¼‰

PCä¿®ç†ã®å®Œäº†ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚Šã€
è«‹æ±‚æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ç”Ÿæˆ â†’ S3 ã«ä¿å­˜ â†’ SES ã§ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã§ã™ã€‚

## æ§‹æˆæŠ€è¡“

- AWS Lambdaï¼ˆPythonï¼‰
- Amazon API Gateway
- Amazon S3ï¼ˆè«‹æ±‚ãƒ‡ãƒ¼ã‚¿ä¿å­˜ï¼‰
- Amazon SESï¼ˆè«‹æ±‚ãƒ¡ãƒ¼ãƒ«é€ä¿¡ï¼‰

## å…¥åŠ›ä¾‹

- ticketId
- customerName / customerEmail
- deviceName
- repairContent
- repairFee / partsFee / taxRateï¼ˆæ¶ˆè²»ç¨ç‡ï¼‰
import json
import uuid
from datetime import datetime, timezone, timedelta
import boto3

s3 = boto3.client("s3")
ses = boto3.client("ses")

S3_BUCKET_NAME = "pc-repair-invoices-bucket"
SENDER_EMAIL = "no-reply@example.com"
JST = timezone(timedelta(hours=9))


def build_invoice(data):
    now = datetime.now(JST)

    invoice_id = f"INV-{now.strftime('%Y%m%d')}-{uuid.uuid4().hex[:8]}"
    repair_fee = int(data.get("repairFee", 0))
    parts_fee = int(data.get("partsFee", 0))
    tax_rate = float(data.get("taxRate", 0.1))

    subtotal = repair_fee + parts_fee
    tax = int(subtotal * tax_rate)
    total = subtotal + tax

    return {
        "invoiceId": invoice_id,
        "ticketId": data.get("ticketId"),
        "issueDate": now.strftime("%Y-%m-%d"),
        "customerName": data.get("customerName"),
        "customerEmail": data.get("customerEmail"),
        "deviceName": data.get("deviceName"),
        "repairContent": data.get("repairContent"),
        "repairFee": repair_fee,
        "partsFee": parts_fee,
        "subtotal": subtotal,
        "tax": tax,
        "total": total
    }


def save_to_s3(invoice):
    key = f"invoices/{invoice['invoiceId']}.json"
    s3.put_object(
        Bucket=S3_BUCKET_NAME,
        Key=key,
        Body=json.dumps(invoice, ensure_ascii=False, indent=2).encode(),
        ContentType="application/json"
    )
    return key


def send_email(invoice):
    if not invoice.get("customerEmail"):
        print("No customerEmail. Skip SES send.")
        return

    subject = f"[è«‹æ±‚æ›¸] PCä¿®ç†ã®ã”è«‹æ±‚ ({invoice['invoiceId']})"
    body = f"""
{invoice['customerName']} æ§˜

PCä¿®ç†ã®ã”åˆ©ç”¨ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚
è«‹æ±‚æ›¸ã‚’ç™ºè¡Œã—ã¾ã—ãŸã€‚

åˆè¨ˆé‡‘é¡: {invoice['total']:,} å††

è©³ç´°ã¯è«‹æ±‚æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’ã”ç¢ºèªãã ã•ã„ã€‚
"""

    ses.send_email(
        Source=SENDER_EMAIL,
        Destination={"ToAddresses": [invoice["customerEmail"]]},
        Message={
            "Subject": {"Data": subject, "Charset": "UTF-8"},
            "Body": {"Text": {"Data": body, "Charset": "UTF-8"}
            }
        },
    )


def lambda_handler(event, context):
    try:
        body = json.loads(event.get("body", "{}"))
        invoice = build_invoice(body)
        key = save_to_s3(invoice)
        send_email(invoice)

        return {
            "statusCode": 200,
            "body": json.dumps(
                {
                    "invoiceId": invoice["invoiceId"],
                    "total": invoice["total"],
                    "s3Key": key,
                    "message": "invoice generated & email sent"
                },
                ensure_ascii=False
            )
        }

    except Exception as e:
        print("Error:", e)
        return {
            "statusCode": 500,
            "body": json.dumps({"error": "internal server error"})
        }

